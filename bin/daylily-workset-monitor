#!/usr/bin/env python3
"""Run the Daylily workset monitor or execute targeted monitor actions."""

from __future__ import annotations

import argparse
import logging
import os
import sys
from pathlib import Path
from typing import Any, Optional, Sequence

from daylib.workset_monitor import (
    MonitorConfig,
    MonitorError,
    WorksetMonitor,
    configure_logging,
)

LOGGER = logging.getLogger("daylily.workset_monitor.cli")


def parse_args(argv: Optional[Sequence[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Monitor S3 workset directories and launch Daylily pipelines",
    )
    supported_actions = ", ".join(
        WorksetMonitor.DEFAULT_ACTION_SEQUENCE + WorksetMonitor.OPTIONAL_ACTIONS
    )
    parser.add_argument("config", type=Path, help="Path to the YAML configuration file")
    parser.add_argument(
        "--once",
        action="store_true",
        help="Run a single poll iteration and exit (ignored when --action is provided)",
    )
    parser.add_argument("--dry-run", action="store_true", help="Do not mutate S3 or execute commands")
    parser.add_argument(
        "--attempt-restart",
        action="store_true",
        help="Retry failed workset commands once starting from the failed command",
    )
    parser.add_argument("--verbose", action="store_true", help="Enable debug logging")
    parser.add_argument("--debug", action="store_true", help="Print all commands executed (and in dry-run)")
    parser.add_argument(
        "--force-recalculate",
        action="store_true",
        help="Recalculate all remote workset metrics regardless of cache",
    )
    parser.add_argument(
        "--process-directory",
        dest="process_directories",
        metavar="NAME",
        nargs="+",
        help="Only process the specified workset directory names",
    )
    parser.add_argument(
        "--include-archive",
        action="store_true",
        dest="include_archive",
        help="Include archived worksets when executing actions",
    )
    parser.add_argument(
        "--action",
        dest="actions",
        action="append",
        metavar="NAME",
        help=(
            "Execute a specific monitor action instead of running the continuous monitor. "
            f"Supported actions: {supported_actions}"
        ),
    )
    # Integration layer options
    parser.add_argument(
        "--enable-dynamodb",
        action="store_true",
        help="Enable DynamoDB state tracking integration",
    )
    parser.add_argument(
        "--dynamodb-table",
        default=os.environ.get("DAYLILY_DYNAMODB_TABLE", "daylily-worksets"),
        help="DynamoDB table name for workset state (default: daylily-worksets)",
    )
    parser.add_argument(
        "--enable-notifications",
        action="store_true",
        help="Enable SNS notifications for workset events",
    )
    parser.add_argument(
        "--sns-topic-arn",
        default=os.environ.get("DAYLILY_SNS_TOPIC_ARN"),
        help="SNS topic ARN for notifications",
    )
    parser.add_argument(
        "--parallel",
        type=int,
        default=1,
        metavar="N",
        help="Maximum number of worksets to run in parallel (default: 1)",
    )
    return parser.parse_args(argv)


def setup_integration_components(
    config: MonitorConfig, args: argparse.Namespace
) -> dict[str, Any]:
    """Initialize optional integration components.

    Returns dict with state_db, integration, and notification_manager keys.
    """
    components: dict[str, Any] = {
        "state_db": None,
        "integration": None,
        "notification_manager": None,
    }

    # Setup DynamoDB state tracking
    if args.enable_dynamodb:
        try:
            from daylib.workset_state_db import WorksetStateDB

            state_db = WorksetStateDB(
                table_name=args.dynamodb_table,
                region=config.aws.region,
                profile=config.aws.profile if config.aws.profile else None,
            )
            components["state_db"] = state_db
            LOGGER.info("DynamoDB state tracking enabled (table: %s)", args.dynamodb_table)
        except ImportError:
            LOGGER.warning("DynamoDB integration requested but workset_state_db module not available")
        except Exception as e:
            LOGGER.warning("Failed to initialize DynamoDB state tracking: %s", e)

    # Setup notifications
    if args.enable_notifications and args.sns_topic_arn:
        try:
            from daylib.workset_notifications import NotificationManager, SNSNotificationChannel

            notification_manager = NotificationManager()
            sns_channel = SNSNotificationChannel(
                topic_arn=args.sns_topic_arn,
                region=config.aws.region,
                profile=config.aws.profile if config.aws.profile else None,
            )
            notification_manager.add_channel(sns_channel)
            components["notification_manager"] = notification_manager
            LOGGER.info("SNS notifications enabled (topic: %s)", args.sns_topic_arn)
        except ImportError:
            LOGGER.warning("Notifications requested but workset_notifications module not available")
        except Exception as e:
            LOGGER.warning("Failed to initialize notifications: %s", e)

    # Setup integration layer if DynamoDB is enabled
    if components["state_db"]:
        try:
            from daylib.workset_integration import WorksetIntegration

            integration = WorksetIntegration(
                state_db=components["state_db"],
                bucket=config.monitor.bucket,
                prefix=config.monitor.normalised_prefix(),
                notification_manager=components["notification_manager"],
                region=config.aws.region,
                profile=config.aws.profile if config.aws.profile else None,
            )
            components["integration"] = integration
            LOGGER.info("Integration layer initialized")
        except ImportError:
            LOGGER.warning("Integration layer requested but workset_integration module not available")
        except Exception as e:
            LOGGER.warning("Failed to initialize integration layer: %s", e)

    return components


def main(argv: Optional[Sequence[str]] = None) -> int:
    args = parse_args(argv)
    configure_logging(args.verbose)

    config = MonitorConfig.load(args.config)
    if args.once and not args.actions:
        config.monitor.continuous = False

    # Apply command-line parallel setting
    if args.parallel > 0:
        config.monitor.max_concurrent_worksets = args.parallel

    # Initialize integration components
    components = setup_integration_components(config, args)

    monitor = WorksetMonitor(
        config,
        dry_run=args.dry_run,
        debug=args.debug,
        process_directories=args.process_directories,
        attempt_restart=args.attempt_restart,
        force_recalculate_metrics=args.force_recalculate,
        state_db=components["state_db"],
        integration=components["integration"],
        notification_manager=components["notification_manager"],
    )

    if args.actions:
        try:
            monitor.perform_actions(
                args.actions,
                include_archive=args.include_archive,
            )
        except MonitorError as exc:
            LOGGER.error("Action execution failed: %s", exc)
            return 1
        return 0

    monitor.run()
    return 0


if __name__ == "__main__":
    sys.exit(main())
